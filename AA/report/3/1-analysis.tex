\chapter{Аналитический раздел}
\label{cha:analysis}

В данном разделе будет приведено описание алгоритмов и модель
вычислений для оценок трудоемкости.

\section{Описание алгоритмов}

Алгоритмы сортировки оцениваются по скорости выполнения и эффективности использования памяти.
В этом разделе будет приведено три алгоритма:
сортировка пузырьком, сортировка вставками и сортировка слиянием.

\subsection{Сортировка пузырьком}

Алгоритм состоит из повторяющихся проходов по сортируемому массиву.
За каждый проход элементы последовательно сравниваются попарно и,
если порядок в паре неверный, выполняется обмен элементов.
Проходы по массиву повторяются $N-1$ раз или до тех пор, пока на очередном
проходе не окажется, что обмены больше не нужны, что означает - массив отсортирован.
\\

\textbf{Сложность по времени}

\begin{itemize}
    \item лучшее время: $O(n)$
    \item среднее время: $O(n^2)$
    \item худшее время: $O(n^2)$
\end{itemize}

\textbf{Затраты памяти:} $O(1)$


\subsection{Сортировкa вставками}

В начальный момент отсортированная последовательность пуста.
На каждом шаге алгоритма выбирается один из элементов входных данных и помещается на
нужную позицию в уже отсортированной последовательности до тех пор,
пока набор входных данных не будет исчерпан.
В любой момент времени в отсортированной последовательности элементы удовлетворяют
требованиям к выходным данным алгоритма.
\\

\textbf{Сложность по времени}

\begin{itemize}
    \item лучшее время: $O(n)$
    \item среднее время: $O(n^2)$
    \item худшее время: $O(n^2)$
\end{itemize}

\textbf{Затраты памяти:} $O(1)$


\subsection{Сортировка слиянием}

Сортируемый массив разбивается на две части примерно одинакового размера.
Каждая из получившихся частей сортируется отдельно.
Два упорядоченных массива половинного размера соединяются в один.
\\

\textbf{Сложность по времени}

\begin{itemize}
    \item лучшее время: $O(n \ log(n))$
    \item среднее время: $O(n \ log(n))$
    \item худшее время: $O(n \ log(n))$
\end{itemize}

\textbf{Затраты памяти:} $O(n)$



\subsection{Модель вычислений}

В данной работы используется следующая модель вычислений:

\begin{enumerate}
    \item Стоимость базовых операций: $F = 1$\\
    $(=, *, +, -, /, \%, <, <=, >, >=, ==, !=, [], +=, -=, *=, /=)$

    \item Стоимость цикля $for$\\
    \begin{equation}
    F_{for} = f_{init} + f_{compare} + N_{loop} \cdot (f_{body} + f_{inc} + f_{compare})
    \label{eq:1.1}
    \end{equation}

    \item Трудоемкость условного оператора $if$\\
    \begin{equation}
    F_{if} = f_{compare} + f_{body} = f_{compare}
    + \left\{
            \begin{array}{ll}
                f_{min}, \hspace{0.5cm} $лучший случай$\\
                f_{max}, \hspace{0.5cm} $худший случай$\\
            \end{array}
            \right.
    \label{eq:1.2}
    \end{equation}
\end{enumerate}

\section{Вывод}
Были приведено описание алгоритмов сортировка пузырьком, сортировка вставками
и сортировка слиянием, также рассмотрено модель вычислений для оценок трудоемкости.
